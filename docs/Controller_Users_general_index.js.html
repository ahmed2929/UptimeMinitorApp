<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Controller/Users/general/index.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/your-github-username/pet-adoption-center-sdk" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Namespaces</h3><ul><li><a href="Auth.html">Auth</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Auth.html#.exports.GenerateAccessResetPasswordToken">exports.GenerateAccessResetPasswordToken</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.GenerateAccessToken">exports.GenerateAccessToken</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.ResendVerificationCode">exports.ResendVerificationCode</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.ResetPassword">exports.ResetPassword</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.SendRestPasswordCode">exports.SendRestPasswordCode</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.VerifyAccount">exports.VerifyAccount</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.logIn">exports.logIn</a></li><li data-type='method' style='display: none;'><a href="Auth.html#.exports.signUp">exports.signUp</a></li></ul></li><li><a href="MedicalCircle.html">MedicalCircle</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.AddCareGiver">exports.AddCareGiver</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.CareGiver">exports.CareGiver</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.ChangeInvitationStatus">exports.ChangeInvitationStatus</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.ChangeInvitationStatusToAcceptDependent">exports.ChangeInvitationStatusToAcceptDependent</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.CreateDependentA">exports.CreateDependentA</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.CreateDependentB">exports.CreateDependentB</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.Dependents">exports.Dependents</a></li><li data-type='method' style='display: none;'><a href="MedicalCircle.html#.exports.getInvitations">exports.getInvitations</a></li></ul></li><li></li><li><a href="Medication.html">Medication</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Medication.html#.exports.CreateNewMed">exports.CreateNewMed</a></li><li data-type='method' style='display: none;'><a href="Medication.html#.exports.EditMed">exports.EditMed</a></li><li data-type='method' style='display: none;'><a href="Medication.html#.exports.deleteMedicationCycle">exports.deleteMedicationCycle</a></li><li data-type='method' style='display: none;'><a href="Medication.html#.exports.getMedication">exports.getMedication</a></li></ul></li><li><a href="routes.html">routes</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Controller/Users/general/index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
/**
 * @file controller/general/index.js
 * @namespace controllers
 * @namespace MedicalCircle
 * 
 */

const User = require("../../../DB/Schema/User");
const MedRecommendation = require("../../../DB/Schema/MedRecommendation");
const SchedulerSchema = require("../../../DB/Schema/Scheduler");
const UserMedication = require("../../../DB/Schema/UserMedication");
const {UploadFileToAzureBlob,GenerateOccurrences,GenerateOccurrencesWithDays} =require("../../../utils/HelperFunctions")
const Occurrence = require("../../../DB/Schema/Occurrences");
const Viewer =require("../../../DB/Schema/Viewers")
const mongoose = require("mongoose");
const {
  successResMsg,
  errorResMsg
} = require("../../../utils/ResponseHelpers");
const Symptom = require("../../../DB/Schema/Symptoms");
const Profile = require("../../../DB/Schema/Profile")
const Permissions = require("../../../DB/Schema/Permissions");
const { findById } = require("../../../DB/Schema/User");



function escapeRegex(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&amp;");
};

// change user lang
exports.ChangeUserDefaultLang = async (req, res) => {
 
  try {

    const {lang}=req.body
    const {id} =req.id
    // get user with email
    const user = await User.findById(id);
    user.lang=lang;
    await user.save()

    // return successful response
    return successResMsg(res, 200, {message:req.t("lang_has_changed")});
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

exports.SearchForMed = async (req, res) => {
 
  try {

    let results=[];
    if (req.query.name) {
     
      // autocomplete search ?

      const regex = new RegExp(escapeRegex(req.query.name), 'i');
      results = await MedRecommendation.find({
        $or:[{PackageName:regex},{GenericName:regex}]
       
        
      }).limit(5);
    } 
    // return successful response
    return successResMsg(res, 200, {data:results});
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};



exports.EditSingleDose=async (req, res) => {

  /** edit singleDose
   * -this api sholud be called when user needs to edit singleDose
   * -the caller must be the med creator or has a permition
   * OccurrenceId is required
   * - data to be edit
   * ********************************
   * logic
   * ********************************
   * 1- make sure that the caller is the med creator
   * 2- make sure that the med id and shcdule id is valid
   * 3- retrive the ocuurence and edit
   * 
   * 
   * 
   */
  try {

    const {id} =req.id
    let {
    OccurrenceId,
    MedInfo,
    PlannedDateTime,
    PlannedDose,
    ProfileID
    }=req.body

    

    
    const oldOccurrence=await Occurrence.findById(OccurrenceId)
    if(!oldOccurrence){
      return errorResMsg(res, 400, req.t("invalid_occurrence_id"));
    }

     /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })

    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }

    // check if the user is the owner and has write permission or can add meds

    if(profile.Owner.User._id.toString()!=id){
      // check if the user has add med permission
      const hasWritePermissonToAllMeds=viewer.CanEditDoses;
      // check CanReadSpacificMeds array inside viewer for the CanWrite permission for that MedID
      const hasWritePermissonToThatDose=viewer.CanReadSpacificMeds.find((med)=>{
        if(med.Med.toString()===oldOccurrence.Medication.toString()){
          return med.CanEditDoses
        }
      }) 
      if(!(hasWritePermissonToThatDose||hasWritePermissonToAllMeds)){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      
    }
    //case the owner dont has write permission
    if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.write){
      return errorResMsg(res, 401, req.t("Unauthorized"));
    }


    // start edit Occurrence
    
    // update 
    oldOccurrence.PlannedDateTime=PlannedDateTime||oldOccurrence.PlannedDateTime
    oldOccurrence.PlannedDose=PlannedDose||oldOccurrence.PlannedDose
    oldOccurrence.MedInfo={
      strength:MedInfo.strength||oldOccurrence.MedInfo.strength,
      unit:MedInfo.unit||oldOccurrence.MedInfo.unit,
      quantity:MedInfo.quantity||oldOccurrence.MedInfo.quantity,
      instructions:MedInfo.instructions||oldOccurrence.MedInfo.instructions,
      condition:MedInfo.condition||oldOccurrence.MedInfo.condition,
      type:MedInfo.type||oldOccurrence.MedInfo.type,
      name:MedInfo.name||oldOccurrence.MedInfo.name,
      ScheduleType:MedInfo.ScheduleType||oldOccurrence.MedInfo.ScheduleType,
      
    }
    oldOccurrence.EditedBy=viewerProfile._id
    await oldOccurrence.save()
    
    // return successful response
    return successResMsg(res, 200, {message:req.t("Occurrence_Updated")});
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};


exports.SuspendDoses=async (req, res) => {

  /** suspend doses form date to date
   * ********************************
   * logic
   * ********************************
   * -1 retrive all occurrences form date to date
   * -2 flage it as suspended
   * 
   * 
   */
  try {

    const {id} =req.id
    let {
    SchedulerId,
    StartDate,
    EndDate,
    ProfileID
    }=req.body

    // check for permison
    const Scheduler =await SchedulerSchema.findById(SchedulerId)
    if(!Scheduler){
      return errorResMsg(res, 400, req.t("Scheduler_not_found"));
    }
      /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })

    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
    // check if the user is the owner and has write permission or can add meds

    if(profile.Owner.User._id.toString()!=id){
      // check if the user has add med permission
      const hasWritePermissonToThatMed=viewer.CanEditAllMeds;
      // check CanReadSpacificMeds array inside viewer for the CanWrite permission for that MedID
      const hasWritePermissonToThatDose=viewer.CanReadSpacificMeds.find((med)=>{
        if(med.Med.toString()===Scheduler.medication.toString()){
          return med.CanWrite
        }
      }) 
      if(!(hasWritePermissonToThatDose||hasWritePermissonToThatMed)){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      
    }
    //case the owner dont has write permission
    if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.write){
      return errorResMsg(res, 401, req.t("Unauthorized"));
    }


    
    //retrive all the occurrences between two dates and mark them as suspended

    await Occurrence.updateMany({
      Scheduler:SchedulerId,
      PlannedDateTime:{$gte:StartDate,$lte:EndDate},
    
    },{
      isSuspended:true
    })
    // return successful response
    return successResMsg(res, 200, {message:req.t("Dose_suspended")});
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

exports.ChangeDoseStatus=async (req, res) => {

  /** change dose status
   * ********************************
   * logic
   * ********************************
   * -1 get dose by id
   * -2 change its status to the new one
   * **********
   *  0: Status mean it's not yet active (future dose), --default
   *  1: Status mean it's in Transit (time is here , not yet 60 mins passed), --server action
   *  2: status code means it's taken. , --action by user
   *  3: it's ignored (60 minutes passed no action) --server action
   *  4: status means its rejected
   * 
   */
  try {

    const {id} =req.id
    let {
    OccurrenceId,
    Status,
    ProfileID
    }=req.body

    // check for permison
    const dose =await Occurrence.findById(OccurrenceId)
    if(!dose){
      return errorResMsg(res, 400, req.t("Dose_not_found"));
    }
    //permission check

          /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })
    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }

    // check if the user is the owner and has write permission or can add meds

    if(profile.Owner.User._id.toString()!=id){
      // check if the user has add med permission
      const hasWritePermissonToThatMed=viewer.CanEditDoses;
      // check CanReadSpacificMeds array inside viewer for the CanWrite permission for that MedID
      const hasWritePermissonToThatDose=viewer.CanReadSpacificMeds.find((med)=>{
        if(med.Med.toString()===dose.Medication.toString()){
          return med.CanEditDoses
        }
      }) 
      if(!(hasWritePermissonToThatDose||hasWritePermissonToThatMed)){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      
    }
    //case the owner dont has write permission
    if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.write){
      return errorResMsg(res, 401, req.t("Unauthorized"));
    }





    if(!(Status==2||Status==4)){
      return errorResMsg(res, 400, req.t("Invalid_status"));
    }

    // edit quantaty
    if(Status==2){
      const Medication=await UserMedication.findById(dose.Medication)
      Medication.quantity=Medication.quantity-dose.PlannedDose
      await Medication.save()
    }
    // change dose status
    
   dose.Status=Status
    await dose.save()

    

    // return successful response
    return successResMsg(res, 200, {message:req.t("Dose_Status_Changed")});
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};


exports.getDoses=async (req, res) => {

  /** 
   * return doses with a spacic date
   * if no date is provided the default is today
   * returns not suspended dosages
   * 
   */
  try {

    const {id} =req.id
    let {
    date,
    ProfileID,
    EndDate
    }=req.query

             /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })
    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
    // check if the user is the owner and has write permission or can add meds
      //case the owner dont has write permission
      if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.read){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      let hasGeneralReadPermissions;
      let hasSpacificReadPermissions;
      if(profile.Owner.User._id.toString()===id){
        hasGeneralReadPermissions=true
      }else{
        hasGeneralReadPermissions=viewer.CanReadDoses;
        hasSpacificReadPermissions=viewer.CanReadSpacificMeds.map(elem=>{
         if(elem.CanReadDoses){
           return elem.Med
         }
       });
      }
    



    // get Occurrences which equal today
    if(!date){
      date=new Date()
    }
    const queryDate =new Date(+date)
    let nextDay
    if(!EndDate){
      nextDay=new Date(+date)
      nextDay= new Date(nextDay.setDate(nextDay.getDate()+1))
      }else{
      nextDay=EndDate
      }
    
    // case has a general read permissions
    if(hasGeneralReadPermissions){
      const doses =await Occurrence.find({
        ProfileID:ProfileID,
        PlannedDateTime:{$gte:queryDate,$lt:nextDay},
        isSuspended:false
  
      }).select(
        "PlannedDateTime PlannedDose Status Medication Scheduler MedInfo _id"
      )
        // return successful response
    return successResMsg(res, 200, {message:req.t("Success"),data:doses});
    }else if(hasSpacificReadPermissions.length>0){ //has spacific permission
      // case has spacific read permissions
      const doses =await Occurrence.find({
        ProfileID:ProfileID,
        PlannedDateTime:{$gte:queryDate,$lt:nextDay},
        isSuspended:false,
        Medication:{$in:hasSpacificReadPermissions}
  
      }).select(
        "PlannedDateTime PlannedDose Status Medication Scheduler MedInfo _id"
      )
        // return successful response
    return successResMsg(res, 200, {message:req.t("Success"),data:doses});
    }else{
      return errorResMsg(res, 401, req.t("Unauthorized"));
    }
   
    
  
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};



exports.CreateSymptom = async (req, res) => {
 
  try {

    const {id} =req.id
    const {
      ProfileID,
      Type,
      Description,
      Severity,
      StartedIn,
    }=req.body
    /*
    
    check permission will only allow if the id is the Owner id 
    and has a write permission Or
     in Viewers array and has write permission ?
    
    */
    /*
    
    check permission will only allow if the id is the Owner id 
    and has a addMed permission
    
    */
    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })
    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
     
    // check if the user is the owner and has write permission or can add meds

    if(profile.Owner.User._id.toString()!==id){
      // check if the user has add med permission
      const hasAddMedPermissonToMeds=viewer.CanEditSymptoms;

      if(!hasAddMedPermissonToMeds){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      
    }
    //case the owner dont has write permission
    if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.write){
      return errorResMsg(res, 401, req.t("Unauthorized"));
    }


    let img
    // store the image to aure
    if(req.files.img&amp;&amp;req.files.img[0]){
       img = await UploadFileToAzureBlob(req.files.img[0])
    }
    // store voice record to auzre
    let voice
    if(req.files.voice&amp;&amp;req.files.voice[0]){
      voice = await UploadFileToAzureBlob(req.files.voice[0])
    }
   

    // create new Symtom
    const newSymton = new Symptom({
      img,
      Profile:ProfileID,
      User:id,
      Type,
      Description,
      Severity,
      StartedIn,
      VoiceRecord:voice,
      CreatorProfile:viewerProfile._id

    })
    
    await newSymton.save()
  const responseData={
    ...newSymton._doc,
  }
    // return successful response
    return successResMsg(res, 200, {message:req.t("symtom_created"),data:responseData});
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};


exports.getSymptoms=async (req, res) => {

  /** 
   *return all user Medication 
   * 
   */
  try {

    const {id} =req.id
    const {ProfileID,StartDate,EndDate}=req.query
    console.log(ProfileID)
             /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })

    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }

    // check if the user is the owner or has a read permissions
      if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.read){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
  
    let hasGeneralReadPermissions;
    if(profile.Owner.User._id.toString()===id){
      hasGeneralReadPermissions=true
    }else{
      hasGeneralReadPermissions=viewer.CanReadSymptoms;
    }
  
    
   
  
 

  // case general permission
  if(hasGeneralReadPermissions){
    const symptoms =await Symptom.find({
      Profile:ProfileID,
      StartedIn:{
        $gte:new Date(+StartDate),
        $lte:new Date (+EndDate)
      },
      isDeleted:false

    }).populate({
      path:"CreatorProfile",
      select:"firstName lastName img",
      populate:{
        path:"Owner.User",
        select:"firstName lastName img"
      }
    })
   
    
    // return successful response
    return successResMsg(res, 200, {message:req.t("Success"),data:symptoms});

  
  }else{
    return errorResMsg(res, 401, req.t("Unauthorized"));
  }

   
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

exports.getReport=async (req, res) => {

  /** 
   *return all user Medication 
   * 
   */
  try {

    const {id} =req.id
    const {ProfileID,StartDate,EndDate}=req.query


             /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })

    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
    // check if the user is the owner and has write permission or can add meds
      //case the owner dont has write permission
      if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.read){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      let hasGeneralReadPermissions;
      let hasSpacificReadPermissions;
      if(profile.Owner.User._id.toString()===id){
        hasGeneralReadPermissions=true
      }else{
         hasGeneralReadPermissions=viewer.CanReadDoses;
         hasSpacificReadPermissions=viewer.CanReadSpacificMeds.map(elem=>{
          if(elem.CanReadDoses){
            return elem.Med
          }
        });
      }
    
  
   
 

  // case general permission
  if(hasGeneralReadPermissions){
     // case spacific permission
     const doses =await Occurrence.aggregate([{
       $match:{
         ProfileID: mongoose.Types.ObjectId(ProfileID),
         PlannedDateTime:{$gte:new Date(+StartDate),$lte:new Date(+EndDate)},
         isSuspended:false,
        
       }
     },
     
        {
          $group: {
           _id: {
             Medication: '$Medication',
           },
           confirmed: {
             $sum: {
               $cond: {
                 if: { $eq: ['$Status', 2] },
                 then: 1,
                 else: 0
               }
             }
           },
           rejected: {
             $sum: {
               $cond: {
                 if: { $eq: ['$Status', 4] },
                 then: 1,
                 else: 0
               }
             }
           },
           ignored: {
            $sum: {
              $cond: {
                if: { $eq: ['$Status', 3] },
                then: 1,
                else: 0
              }
            }
          },
           other: {
             $sum: {
               $cond: {
                 if: { $in: ['$Status', [0,1]] },
                 then: 1,
                 else: 0
               }
             }
           },
           total: { $sum: 1 },
         
     }
       }
 
     ])
 
     const responseData=[];
 
     for (const elem of doses) {
       const med =await UserMedication.findById(elem._id.Medication).select("name img unit strength")
       responseData.push({
         med:med,
         confirmed:elem.confirmed,
         rejected:elem.rejected,
         other:elem.other,
         total:elem.total,
          ignored:elem.ignored
       })
     }
 
  
     // return successful response
     return successResMsg(res, 200, {message:req.t("Success"),data:responseData});

  }else if(hasSpacificReadPermissions.length>0){
    // case spacific permission
    ids = hasSpacificReadPermissions.map(function(el) { return mongoose.Types.ObjectId(el) })

    const doses =await Occurrence.aggregate([{
      $match:{
        ProfileID: mongoose.Types.ObjectId(ProfileID),
        PlannedDateTime:{$gte:new Date(+StartDate),$lte:new Date(+EndDate)},
        Medication:{$in:ids},
        isSuspended:false,
      }
    },
    
    
       {
         $group: {
          _id: {
            Medication: '$Medication',
          },
          confirmed: {
            $sum: {
              $cond: {
                if: { $eq: ['$Status', 2] },
                then: 1,
                else: 0
              }
            }
          },
          rejected: {
            $sum: {
              $cond: {
                if: { $eq: ['$Status', 4] },
                then: 1,
                else: 0
              }
            }
          },
          ignored: {
            $sum: {
              $cond: {
                if: { $eq: ['$Status', 3] },
                then: 1,
                else: 0
              }
            }
          },
          other: {
            $sum: {
              $cond: {
                if: { $in: ['$Status', [0,1]] },
                then: 1,
                else: 0
              }
            }
          },
          total: { $sum: 1 },
        
    }
      }

    ])

    const responseData=[];

    for (const elem of doses) {
      const med =await UserMedication.findById(elem._id.Medication).select("name img unit strength")
      responseData.push({
        med:med,
        confirmed:elem.confirmed,
        rejected:elem.rejected,
        other:elem.other,
        total:elem.total,
        ignored:elem.ignored
      })
    }

 
    // return successful response
    return successResMsg(res, 200, {message:req.t("Success"),data:responseData});
  }else{
    return errorResMsg(res, 401, req.t("Unauthorized"));
  }

    
   
   
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

exports.getReportSingleMed=async (req, res) => {

  /** 
   *return all user Medication 
   * 
   */
  try {

    const {id} =req.id
    const {ProfileID,StartDate,EndDate,MedID}=req.query


             /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })

    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
    // check if the user is the owner and has write permission or can add meds
      //case the owner dont has write permission
      if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.read){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      let hasGeneralReadPermissions;
      let hasSpacificReadPermissions;
      if(profile.Owner.User._id.toString()===id){
        hasGeneralReadPermissions=true
      }else{
         hasGeneralReadPermissions=viewer.CanReadDoses;
         hasSpacificReadPermissions=viewer.CanReadSpacificMeds.map(elem=>{
          if(elem.CanReadDoses){
            return elem.Med.toString()
          }
        });
      }
    
  
 

  // case general permission
  if(hasGeneralReadPermissions){
     // case spacific permission
     const doses =await Occurrence.find({
  
         ProfileID: mongoose.Types.ObjectId(ProfileID),
         PlannedDateTime:{$gte:new Date(+StartDate),$lte:new Date(+EndDate)},
          Medication:mongoose.Types.ObjectId(MedID)
     }).populate(
     {
        path:"Medication",
        select:"name img unit strength type"
     }
     ).select("-MedInfo")
     
    
 
  
     // return successful response
     return successResMsg(res, 200, {message:req.t("Success"),data:doses});

  }else if(hasSpacificReadPermissions.length>0){

     // if the MedID is not in hasSpacificReadPermissions array return unauzorized
  if(!hasSpacificReadPermissions.includes(MedID)){
    return errorResMsg(res, 401, req.t("Unauthorized"));
  }
  


     const doses =await Occurrence.find({
  
      ProfileID: mongoose.Types.ObjectId(ProfileID),
      PlannedDateTime:{$gte:new Date(+StartDate),$lte:new Date(+EndDate)},
       Medication:mongoose.Types.ObjectId(MedID),
       isSuspended:false
  }).populate(
  {
     path:"Medication",
     select:"name img unit strength type"
  }
  ).select("Medication PlannedDateTime PlannedDose Status ProfileID")
  
 


  // return successful response
  return successResMsg(res, 200, {message:req.t("Success"),data:doses});
    

    // return successful response
    return successResMsg(res, 200, {message:req.t("Success"),data:doses});
  }else{
    return errorResMsg(res, 401, req.t("Unauthorized"));
  }

    
   
   
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

exports.getAllDoses=async (req, res) => {
  /**
   * get my doses and my dependents doses
   * 
   * 
   */
  /** 
   * return doses with a spacic date
   * if no date is provided the default is today
   * returns not suspended dosages
   * 
   */
  try {

    const {id} =req.id
    let {
    date,
    ProfileID,
    EndDate
    }=req.query

             /*
    
    check permission 
    
    */

    const profile =await Profile.findById(ProfileID)
    if(!profile){
      return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    // get the viewer permissions
    const viewerProfile =await Profile.findOne({
    "Owner.User":id
    })
    
    if(!viewerProfile){
       return errorResMsg(res, 400, req.t("Profile_not_found"));
    }

    const viewer =await Viewer.findOne({
     ViewerProfile:viewerProfile._id,
     DependentProfile:ProfileID
    })
    if(!viewer&amp;&amp;profile.Owner.User._id.toString()!==id){
      return errorResMsg(res, 400, req.t("Unauthorized"));
    }
    // check if the user is the owner and has write permission or can add meds
      //case the owner dont has write permission
      if(profile.Owner.toString()===id&amp;&amp;!profile.Owner.Permissions.read){
        return errorResMsg(res, 401, req.t("Unauthorized"));
      }
      let hasGeneralReadPermissions;
      let hasSpacificReadPermissions;
      if(profile.Owner.User._id.toString()===id){
        hasGeneralReadPermissions=true
      }else{
        hasGeneralReadPermissions=viewer.CanReadDoses;
        hasSpacificReadPermissions=viewer.CanReadSpacificMeds.map(elem=>{
         if(elem.CanReadDoses){
           return elem.Med
         }
       });
      }
    



    // get Occurrences which equal today
    if(!date){
      date=new Date()
    }
    const queryDate =new Date(+date)
    let nextDay
    if(!EndDate){
      nextDay=new Date(+date)
      nextDay= new Date(nextDay.setDate(nextDay.getDate()+1))
      }else{
      nextDay=EndDate
      }
    
      // get all my dependents
    const mydependents =await Viewer.find({
      ViewerProfile:viewerProfile._id
    })
    
    const dependentsProfiles =mydependents.filter(elem=>{
      return elem.CanReadDoses;
    })
    const dependentsProfilesIDs =dependentsProfiles.map(elem=>{
      return elem.DependentProfile
    })
    // push the viewer profile to dependentsProfileIDs
    dependentsProfilesIDs.push(viewerProfile._id)

    // get general permissions doses
    const generalDoses =await Occurrence.find({
      ProfileID:{$in:dependentsProfilesIDs},
      PlannedDateTime:{$gte:queryDate,$lt:nextDay},
      isSuspended:false

    }).select(
      "PlannedDateTime PlannedDose Status Medication Scheduler MedInfo _id ProfileID"
    )
    .populate({
      path:"ProfileID",
      select:"Owner.User",
      populate:{
        path:"Owner.User",
        select:"firstName lastName email"
      }

    })

    // get doses which i has read permissions to
    const dependentsWithSpacific =mydependents.filter(elem=>{
      return !elem.CanReadDoses;
    })
    const dependentsSpacificMeds =[]
    
    dependentsWithSpacific.forEach(dependent=>{
      dependent.CanReadSpacificMeds.forEach(elem=>{
        if(elem.CanReadDoses){
          dependentsSpacificMeds.push(elem.Med)
        }
      })

    })
    const spacificDoses =await Occurrence.find({
      PlannedDateTime:{$gte:queryDate,$lt:nextDay},
      isSuspended:false,
      Medication:{$in:dependentsSpacificMeds}

    })
    .select("PlannedDateTime PlannedDose Status Medication Scheduler MedInfo _id ProfileID")
    .populate({
      path:"ProfileID",
      select:"Owner",
      populate:{
        path:"Owner.User",
        select:"firstName lastName email"
      }

    })
    
const doses=[...generalDoses,...spacificDoses]


  return successResMsg(res, 200, {message:req.t("Success"),data:doses});

   
    
  
    
  } catch (err) {
    // return error response
    console.log(err)
    return errorResMsg(res, 500, err);
  }
};

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Thu Jan 12 2023 13:12:01 GMT+0200 (Eastern European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
